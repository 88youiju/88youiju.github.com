<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>AppScope: Application Energy Metering Framework for Android Smartphones using Kernel Activity Monitoring |  Net blog</title>
    <meta name="description" content="hi">
    <meta name="author" content="JuneHyuck Park">
    <meta name="keywords" content="java" />
    <meta name="generator" content="haroopress v0.9.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link href="/rss.xml" rel="alternate" title="Net blog" type="application/rss+xml">

    <!-- Le styles -->
    <link rel="canonical" href="88youiju.github.com">

    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/bootstrap-responsive.css" rel="stylesheet">
    <link href="/css/font-awesome.css" rel="stylesheet">
    <link href="/css/markdown.css" rel="stylesheet">
    <link href="/css/haroopress.css" rel="stylesheet">
    <link href="/css/theme.css" rel="stylesheet">
    <link href="/css/code/default.css" rel="stylesheet">
    
    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="apple-touch-icon" sizes="72x72" href="/favicon-64.png">

    <!-- Le javascript -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/jquery.jsonp.js"></script>
    <script src="/js/mustache.js"></script>
    <script src="/js/apps/github.js"></script>
    <script src="/js/apps/twitter.js"></script>
</head>
<body data-spy="scroll" data-target=".subnav" data-offset="50">

        <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>

          <a class="pull-right" href="/rss.xml"><span class="icon-rss"></span></a>
          

          <div class="nav-collapse">
            <ul class="nav">
              <li>
                <a href="/">Home</a>
              </li>
              <li>
                <a href="/archives">Archives</a>
              </li>
              <li>
                <a href="/slides">Slides</a>
              </li>
                
            </ul>
          </div>
        </div>
      </div>
    </div>

    
<link href="/css/code/default.css" rel="stylesheet">
<div class="container page-archive">
    <div class="row">
        <div class="span3">
            <div id="author" class="well">
                <div>
                    <h3>About Author</h3>
                    <ul class="thumbnails">
                        <li>
                            <a class="thumbnail">
                                <img src="http://www.gravatar.com/avatar/c53425ebe2364d712cd0b48d9fbc10a9?r=pg&amp;s=128.jpg&amp;d=identicon" />
                            </a>
                        </li>
                    </ul>
                    <p>
                        <strong>JuneHyuck Park</strong><br/>
                        blog: <a href="88youiju.github.com" target="_blank">88youiju.github.com</a><br/>
                        twitter: <a href="http://twitter.com/" target="_blank">@</a><br/>
                        github: <a href="https://github.com/" target="_blank"></a>
                    </p>
                    <p>
                        <a href="https://twitter.com/" class="twitter-follow-button" data-show-count="true">Follow @</a>
                        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
                    </p>
                    <p>
                        <p><strong>Please! edit your profile</strong></p>
                    </p>
                </div>
                <div>
                    <h3>About this Article</h3>
                    <p>
                        <h5>Date Released:</h5>
                        <span>Saturday, January 19 2013 1:11 PM</span>
                    </p>
                </div>
            </div>
                        <div class="well">
                <ul class="nav nav-list">
                    <li class="nav-header">Categories</li>
                    <li class=""><a href="/category"><i class="icon-home"></i> Home</a></li>
                    
                    <li><a href="/category/paper"><i class="icon-book"></i> paper</a></li>
                    
                    <li><a href="/category/android"><i class="icon-book"></i> android</a></li>
                    
                </ul>
            </div>

            
<div class="well">
    <ul class="nav nav-list">
        <li class="nav-header">Recent Articles</li>
    
        <li>
            <a href="/post/appscope-application-energy-metering-framework-for-android-smartphones-using-kernel-activity-monitoring" target="_blank">AppScope: Application Energy Metering Framework for Android Smartphones using Kernel Activity Monitoring
            <span class="label">JuneHyuck Park</span></a>
        </li>
    
        <li>
            <a href="/post/batterymanager-yoyag" target="_blank">Batterymanager 요약
            <span class="label">JuneHyuck Park</span></a>
        </li>
    
        <li>
            <a href="/post/welcome-to-haroopress" target="_blank">Welcome to haroopress
            <span class="label">haroopress</span></a>
        </li>
    
    </ul>
</div>

        </div>
        <div class="span9">
            <div class="row">
                <div class="span9">
                    <div class="well bg">
                        
                        <div class="page-header">
                            <h1>AppScope: Application Energy Metering Framework for Android Smartphones using Kernel Activity Monitoring</h1>
                        </div>

                        <div class="pull-right social-area">
                                                
                                                

                            
                        </div>

                        <div class="markdown-wrapper">
                            <h2 id="toc_0">AppScope: Application Energy Metering Framework for Android Smartphones using Kernel Activity Monitoring</h2>

<h3 id="toc_1">Abstract</h3>
<p>하드웨어와 시스템 소프트웨어 대한 이해의 부족으로 제한된 접근을 가져서 application의 에너저시 소모를 세밀하게 알려주는것에 한계가 있었다.이것의 문제는 의미있는 정보단위로 에너지 소모를 보여주게 될경우 정확도가 매우 낮아지는 문제를 가진다. 즉, 프로세스 단위, 스레드 단위, 서브루틴 단위로 보여지기 힘들다는 것이다.  </p><p>본 연구에서 AppScope을 제안한다. 이것은 안드로이드 시스템기반의 energy metering system이다. 이 시스템은 각 어플리케이션이 사용하는 커널 레벨의 하드웨어 usage를 monitor 한다. 그리고 정확도 높은 에너지 소모를 알려 준다.</p><p>AppScope은 커널 모듈로 구현 되어졌다. 그리고 이벤트 드리븐 모니터링 방법이기 때문에 low overhead 이며 high accuracy를 가진다. 측정결과 AppScope이 가지는 에너지 소모 오버해드는 35mW이고, CPU utilization overhead는 2.1%이다.</p>
<h3 id="toc_2">1. Introduction</h3>
<p>스마트폰 스스로가 전력을 manage 하기 위해서 스마트폰 에너지 소모 측정이 중요하다.
사용자들은 에너지 소모에 기반하여 합리적으로 어플리케이션을 선택할 수 있어야 한다.
또한 시스템 소프트웨어 개발자와 어플리케이션 개발자들 모두가 각각의 프로세스 또는 하드웨어 컴포넌트 단위의 에너지 소모에 관심있어 한다[1-5].</p><p> 하지만 전력 소모를 알아내는것은 어렵다. 스마트폰은 매우 다양한 하드웨어를 사용하며, 그 각각의 하드웨어는 모두 복잡한 구조를 가지고 있다. 또한 이러한 하드웨어들이 콤팩트하게 엮여 있기 때문에 더 어렵다.
결국, 정확도 높은 파워 모델을 생성하기 위해서는 하드웨어 컴포넌트별로 에너지 소모를 측정 해야 한다.</p><p> 이전연구[6-9]에서 various energy metering method를 실시 했었다. 하지만, 이러한 모델은 granularity와 accuracy가 부족 했다. 하나의 예로 이전연구[6] PowerScope의 경우 application들의 에너지 소모를 fine-grained level로 제공 한다. 그러나 이것은 external device를 이용한 post-processing을 요구한다. 또한 개발자들은 에너지 Metering을 위해서 import related APIs해야 한다.
PowerTutor의 경우도 하드웨어 컴포넌트별 에너지 소모는 나타내 주지만 각각의 어플리케이션별로 또는 프로세스별로 정확한 에너지 소모를 제공해 주지 않는다.
PowerProf[9]의 경우 각각의 어플리케이션을 위한 API usage 정보를 요구한다. 에너지 소모를 추정하기 위해서
위에서 언급한 이러한 전력 모델들은 오직 정확도에 초점을 맞추었다. 하지만 그들은 모두 하드웨어의 actual usage에 대해서는 고려하지 않았다.
결국, 정확한 에너지 추정이란 정확한 전력모델도 중요하고 정확한 하드웨어별 usage statistics가 있어야 한다.
특히 이 heardware usage는 전력소모 추정을 위한 필요조건이기 때문에 더더욱 중요하다.</p><p>  이러한 Hardware Usage를 파악하는 일은 이전에 hardware performance counter(HPC)에 의해서 완성되어진 연구이다[5,10-13]. 소프트웨어 performnace counter(SPC) such as the Linux procfs/sysfs[7,14-16],or BatteryStats, which is provided by Android[8,17].
하지만, 이러한 방법들은 프로세스와 하드웨어에 의존적이며 서로 다른 정보를 제공하게 된다.
따라서 정확한 사용 통계를 각각의 하드웨어 컴포넌트를 위해서 획득하기에는 제한성을 가진다.</p><p>  본 연구에서는, AppScope이라고 부르는 software scheme을 제안한다. 이것은 Android kernel 을 마이크로 스코픽 레벨로 모니터링하는 개념이다. 이렇게해서 각각의 Application의 usage statics를 계산한다. 이를 통해서 시스템 콜을 trace하며, android binder를 trace한다.
AppScope은 Event-driven 접근 방식으로 app usage를 수집한다. 그렇기 때문에 application 수준에서 fine-grained level로 추정이 가능 하다.
또한 우리의 방법은 어떤 안드로이드 디바이스를 위해서도 시스템 소프트웨어의 수정없이 적용이 가능하다. 왜냐하면 우리는 리눅스 커널의 다이나믹 모듈을 이용 했기 때문이다.</p>
<blockquote>
<h3 id="toc_3">The contributions of our work are as follows:</h3>

<ul>
<li>AppScope은 안드로이드 어플리케이션을 위해서 자동으로 에너지 소모를 제공 한다.  시스템소프트웨어를 커스터마이즈하고 하드웨어 컴포넌트들을 커스터마이즈해서</li>
<li>AppScope은 정확한 추정을 한다. 리얼 타임에, hardware usage를 mcrioscopic level로 제공 한다.</li>
<li>우리의 방법이 이식성을 높이기 위해서 kernel module로 개발 했다. 따라서 안드로이드 디바이스<br></li>
</ul>
</blockquote>

<h3 id="toc_4">2. Backgrounds</h3>
<p>  파워 모델은 하드웨어 컴포넌트에 의존적이며
이러한 하드웨어 컴포넌트들은 전통적으로 non-linear regression model 또는 linear regresion 모델로 만들어 졌다.                            </p><p>  non-linear power model들도 종종 hardware component들에 대해서 종속적인 모습을 보였다. 비록 그것들이 충분히 linear model들을 성능적인 측면에서 능가하지 못하지만 말이다[18]. 우리는 따라서 무조건 linear model들로 구성 되어진다. 우리의 linear model들을 이용하면 하나의 디바이스에 대한 전력 소모 P는 아래의 expression을 따른다.</p><p><img src="http://cfile10.uf.tistory.com/image/196FE0394FE1D68214C4D9" alt="My cool picture"></p><p>  x는 하드웨어 컴포넌트의 usage를 나타내며 i는 하드웨어 컴포넌트의 종류 이다. 베타 i는 component의 power coefficient이다. i는 역시 컴포넌트의 종류이다. P base는 기본 전력 소모이고, noise는 Pe지만 측정할 수 없다. 그리고 <code>total energy consumption E</code>의 식은 아래와 같다.</p><p><img src="http://cfile5.uf.tistory.com/image/1114CC364FE1D9F812FF23" alt="My cool picture"></p><p>D는 디바이스의 power-up duration이다. Ej 프로세스 j에 의한 에너지 소모이다, Ej는 위에 식처럼 나온다.</p>
<h6 id="toc_5">결국 전력계수 베타와 usage x 그리고 hardware duration D가 가장 중요하다.</h6>

<h5 id="toc_6">2.2. DevScope</h5>
<p>이전 연구 linear power modeling for mobile devices[7,14,15]는 used external power measurement를 했다. 전력 계수 베타를 구하기 위해서
특히, 이 전력계수는 같은 디바이스일 지라도, 하드웨어 소프트웨어의 configuration에 따라서 또는 battery status에 따라서 다양하다[16,19]</p><p>Typically, these values are directly obtained with hardware measurements for target devices; hence, this offline method is costly and hardly adaptive to changing enviroments.</p><p>  battery monitorring unit(BMU)[16,19]를 통해서 이러한 offline moethod의 limitation을 극복 했다.
이렇게 할경우 자동성이 올라간다 또한 외부 요인 변화에 대해서도 적응성이 올라간다. 외부 요인으로는 노화문제 소프트웨어 업데이트 등을 들 수 있다.
그러나 BMU로 power measurement를 진행할 경우 BMU가 고유하게 필요해야 하기 때문에 그로인에 2개의 factor가 존재하게 된다.<br>
<code>첫번째</code>는 BMU는 noticeably가 매우 lower하다 외부 측정 장치에 비해서<br>
<code>두번째</code>는 사용자는 이러한 전력 모델을 생성하는 것에 전혀 관여하지 않는다. 따라서 시스템의 활동과 전력소모의 관계를 이끌어내기가 매우 어렵다. 매우 임의의 사용 정보에서 Power 계수를 찾아내는것은 불가능 이다.</p><p>  DevScope[19] 스마트폰을 위한 자동 전력 모델 생성 application이다. 이 어플리케이션은 OS의 정보를 수집한다. 수집하는 정보는 각각의 컴포넌트들의 타입과 configuration들이다.
또한, BMU의 활동을 모니터링한다.
DevScope는 가각의 컴포넌트 타입, 시스템 환경설정, BMU 업데이트 rate에 따라서 각각의 컴포넌트 전력 소모를 분석하기위해 다이나믹하게 컨트롤 시나리오를 생성 한다.
또한 비록 스마트폰이 동일할 지라도 시나리오는 아마도 달라질 것이다. 각각 장치마다의 환경설정 때문에. 시나리오라는것은 결국 workload를 각각의 하드웨어 컴포넌트에 할당하는 작업이다.</p>
<h3 id="toc_7">3. AppScope: The Application Energy Metering System</h3>
<p>hardware component 요청에 대한 kernel activity들을 모니터링해서 각 application들에 대한 energy consumption을 정확하고 상세히 제공 한다.</p><p>그림1은 <code>AppScope</code>에 대한 개괄을 보여 준다.
<code>AppScop</code>e은 3단계를 통해서 Application의 energy 소모를 예측하게 된다.</p><p><img src="http://cfile4.uf.tistory.com/image/113A82404FE283EC1AC64C" alt="&lt;Display Name&gt;"></p><p>1) 하드웨어 컴포넌트 접근에 대한 요청을 하는 프로세스를 디텍션 한다.<br>
2) 하드웨어 컴포넌트들의 usage statistics와 status change를 분석 한다.<br>
3) 어플리케이션에 의해서 엑세스 되어진 각 하드웨어 컴포넌트들의 에너지 소모를 adding up함으로써 Linear model based application energy estimation을 한다.</p>
<h5 id="toc_8">3.1 Event Detector</h5>
<p><code>Event Detector</code>는 하드웨어 컴포넌트 사용과 관련된 system call들의 사용에 대해서 수집 한다. 예를 들면, <code>CPU frequency</code> 스위칭, 프로세스 스위칭, <code>packet transmission</code> 그리고 <code>binder I/O control</code>.
즉, Event Detector는 cpufreq<em>cpu</em>put()과 sched<em>switch()를 모니터링 하게 된다.
packet transmission operation들을 위해서는 dev</em>queue<em>xmit()와 netif</em>rx()인 커널 함수를 코니터링 한다.
Binder IO 제어를 위해서는 binder<em>transaction()을 모니터링 한다. 이것은 binder</em>ioctl() 루틴중 일부분이다.
위와 같은 것들이 디텍션 된다음에 <code>Hardware Component Usage Analyzer</code>로 들어가게 된다.</p>
<h5 id="toc_9">3.2 Hardware Component Usage Analyzer</h5>
<p>이벤트들이 dected되어졌을때, hardware Component Usage Analyzer는 각각의 하드웨어 컴포넌트에 대한 usage statistic들을 수집 한다. 그리고 전력 모델을 적용하기 위한 데이터들도 수집한다.
서로다른 커널 오퍼레이션에 의해서 각각의 하드웨어 컴포넌트들은 활동 한다.
게다가, 각각의 정보의 타입은 서로다른 핟웨어 컴포넌트의 특성에 맞추어서 파워모델을 적용하기 위해서 필요로 한다. 따라서 따라서 이 정보 수집방법은 하드웨어 컴포넌트의 정의에 따라 달라진다.
그림 2는 이 서로다른 수집 방법에 대해서 그린 것이다. cpu는 utilization과 frequency인데 이것은 governor interface에 대해서 영향을 받아서 수집되어 진다.
For Wifi, the rate of the ransmitted/received packets of a process is collected by monitoring the data flow in the linux networking stack.
In the case of LCD display and GPS, the duration은 IPC interfacing message를 분석함으로써 조사되어진다.
3G의 경우 Netwrok interface와 Binder Driver를 모두 이용한다.
좀더 자세한 것은 Section. 4에서 언급 한다.</p><p><img src="http://cfile23.uf.tistory.com/image/1202493F4FE2A57230AE83" alt="&lt;Display Name&gt;"></p>
<h3 id="toc_10">3. Application Energy Estimator</h3>
<p>Table1에 있는 전력 모델을 이용해서 하드웨어의 사용 통계량과 결합하여 전력 소모를 추정 한다.</p><p>어플리케이션이란 결국 User ID고 따라서 그 UID에는 많은 PID들이 있다. 따라서 PID의 집합이 UID의 하나의 셋이 되는것이다. 따라서 어플리케이션의 에너지 소모는 그 어플리케이션이 가지고있는 모든 프로세스들의 에너지소모를 합친것이다.
(The application energy consumption energy consumption is then obtained by combining the energy consumption of all processes that belong to an application)
즉 안드로이드 플랫폼에서는 각 어플리케이션은 UID를 가짐으로써 다른 어플리케이션들이 specific resources를 accessing하지 못하게 한다.
AppScope은 어플리케이션의 에너지 소모를 UID를 사용해서 구별 한다.</p><p>In our wrok, we assume that the overall energy consumption of a device running an application includes both <code>&quot;system energy&quot;</code> and <code>&quot;application energy&quot;</code>.  </p>
<blockquote>
<p>basic consumption의 정이란? 결국 디바이스가 동작함에 있어서 Android framework.dl 기본적으로 요구하는 에너지 소모량을 말한다.
it includes the energy consumption for various android system processes as well as for the linux kernel threads. </p></blockquote>
<p>다른 한편으로 Application energy defined as consumption soley used by the processes belonging to an application.</p><p>이 UID에 관해서는 UID=0은 root-owned processes들이 사용한다. 그다음 1000번 까지 Android system processes들이 사용 한다. 그리고 UID 1000번 이상은 일반 어플리케이션이 사용 한다.
AppScope인 이제 이 두가지 측면을 모두 추정하게 된다.</p>
<h3 id="toc_11">4. Application&#39;s Hardware Usage Analysis</h3>
<p>In the section, we describe AppScope&#39;s techniques that are used to detect and analyze how each hardware component is used by an application.</p>
<h5 id="toc_12">4.1 Limitation of Previous Approaches</h5>
<p>이전의 방법에는
HPCs, procfs/sysfs on Lunux, BatteryStats 모두 다 한게가 있다.</p>
<h5 id="toc_13"><code>procfs/sysfs on Lunux</code>의 단점</h5>

<ul>
<li><p>First, the update rate of each hardware component is differnet, as is the data access method.<br>
1) CPU utilization은 updates rate이 5Hz이다.<br>
2) CPU frequency는 provided only for the current status.<br>
이러한 2가지 어려움으로 어플리케이션의 CPU utilization에 따른 frequency는 분석하기가 어렵다.<br>
또한 procfs/sysfs access의 constraint 때문에, 계속해서 polling 해야하는 어려움이 있다.  </p></li>
<li><p>Second, the details of the information obtained from the filesystem vary depending on the type of underlying hardware.<br>
For example, WiFi traffic is not provided for process bases and GPS usage information is generally not available.  </p></li>
<li><p>Last, 비록 앞선 limiting factor들이 can be alleviated with kernel modification일지라도, 그렇게 할경우 don&#39;t suuport diverse platforms because of generally not be modified on in case of common users.</p></li>
</ul>

<blockquote>
<p>결국 사람들이 Power Model을 계속하는 이유는, fined-grained 하게 만들어서 최대한 granularty를 높여서 뭔가 의미있는 결과를 관찬하기 위함이다. Power Model이 얼마나 정교하느냐 그런것은 중요하지 않다. 정확도가 문제가 아니라, 얼마나 granularty가 잘되는가이다. 결국 이게 안되면 만들어 놓고도 최적화기술에 적용하기에는 너무 granularty가 낮아서 힘들다는 말이다.</p><p>결국은 잘 프로파일링해서 잘 생성한 모델과 결합하는것이다.
모델도 빠르고 쉽게 만들고,
만든것도 하드웨어 사용 통계와 잘 결합시키는것 그게 포인트다.
그렇지 않으면 최적화에 사용 할 수가 없다.</p></blockquote>
<p>BatteryStats는 결국 똑같은 문제로 힘들다. 설상가상으로 이건 granularity가 매우 다양하다. 즉 뭐냐면
하나의 정보에 cpu wifi display이런 정보가 맊 썩인다는 것이다.</p>
<h5 id="toc_14">4.2 Kernel Activity Monitoring</h5>
<p>android application은 2가지 방법으 하드웨어를 엑세스하게된다.
첫번째는 kernel level의 시스템콜을 사용 하는 방법이다.
두번째는, android binder를 통하여 RPC를 요청하는 것이다.</p><p>이번 장에서는 어떻게 AppScope가 안드로이드 binder RPC 매커니즘을 컴포넌트 usage를 분석하기위해 사용하는지를 설명 한다. 또한 system call을 어떻게 수집해서 usage data를 얻어내는지도 설명 한다.</p>
<h5 id="toc_15">4.2.1 Android Binder RPC</h5>
<p><img src="http://cfile22.uf.tistory.com/image/187A824B4FE2C8822559AA" alt="&lt;Display Name&gt;"></p><p>Android RPC는 binder RPC protocol을 사용해서 실행 된다.
이 binder RPC는 리눅스 커널의 binder driver에 의해서 처리되는 것이다.
그림 3은 Android IPC의 data format을 보여 준다. </p><p>일단 Android Binder IPC Data가 들어오고 이것은 biinder RPC procedure의 커맨드 BC<em>TRANSACTION를 위해서 사용 되어 진다.
많은 서비스 어플리케이션들의 stub interface를 실행할려고, BC</em>TRANSACTION commnad는 binder driver로 보내진다 
At this moment, IPC data는 binder<em>ioctl()로써 binder diver로 보내지게 된다. 그리고 binder</em>transaction()은 BC_TRANSATION command를 binder driver안에서 실행한다.
따라서 <code>AppScope</code>은 <code>binder_transaction()</code>안에 있는 IPC data processed를 분석 한다. 또한 system usage에 대한 data를 분석 한다.
<code>BC_TRANSACTION</code>은 <code>binder_transaction_data</code>의 RPC 코드를 사용해서 요청하는 기능과는 다르다. 그림 3에서 보여지는 것과 같이.</p><p>요청 커맨드의 상세한 정보는 RPC data 안의 System service name과 Function Input Parameter로 정해진다.</p>
<h5 id="toc_16">4.2.2 Kprobes</h5>
<p>Kprobes[22]는 커널의 system call들을 모니터링하기 위해서 사용되어 진다. Kprobes는 리눅스 디버깅 매커니즘중 하나이다. 그것은 커널 런타임중에 동적으로 브레이크 포인터를 삽입 시키게된다.
It can be inserted into any kernel routine and collect information non-destructively and without intruding into original kernel behavior.
이러한 매커니즘으로 시스템 콜을 모니터링 하는것에 대해서 low overhead를 가지게 된다. 왜냐하면 오직 싱글 인스트럭션만으로 서브루틴의 커널 operation을 탐지할 수 있기 때문이다.
AppScope uses Kprobes to detect events on hardware component operations and to analyze a component&#39;s usage statistics.
AppScope는 커널 모듈로서 컴파일 되고 동적으로 제어 한다. 따라서 installing과 removing을 모듈로써 하는것 외에도, 어떤 추가 적인 작업을 사용자에게 요구하지 않는다.</p>
<h5 id="toc_17">4.3 CPU Usage</h5>
<p>프로세스 Px의 에너지 소모를 측정하기 위해서, 우리는 utilization u 뿐만아니라 utilization과 관련된 CPU frequency 주어진 time unit에 대해서
리눅스 커널에서 Px의 이용률을 계산하기 위해서 Px가 가지는 utime()/stime()을 이용 한다.
TASK<em>RUNNING state에서 어떤 다른 상태로 스위칭 되는것을 디텍팅함으로써 utime()/stime()이 estimation 되어 진다.
중요한것은 이렇게 모든 프로세스에 대해서 이용률을 업데이팅 할경우 많은 오버해드를 발생 시킨다.
오버해드를 감소 시키기 위해서 AppScope은 process 변환을 탐지한다. sche</em>switch() 함수를 통한 이벤트 웨이크업 모니터링으로써
Wake-up 이벤트가 발생될때, AppScope은 이전 프로세스의 이용률을 새로 계산해서 업데이트 한다.</p><p>The CPU frequency changes according to the dynamic voltage and frequency scaling(DVFS) governor in the kernel.
cpufrequ<em>cpu</em>put() function invokes a change in the frequency of the DVFS governor.
따라서 이 함수는 모니터링 되어진다. 그리고 frequency information은 획득 되어진다. 이 함수의 호추 타임에.
Frequency information, as well as information regarding system time, is then stored. Figure 4 illustrates the concept of the mechanism. Here, both the frequency change and the utilization value are computed based on the system time (jiffies), and each color indicates a separate process.</p><p> <img src="http://cfile6.uf.tistory.com/image/14352B354FE461550144FD" alt="&lt;Display Name&gt;"></p>
<h5 id="toc_18">4.4 WiFi Usage</h5>
<p>커널 디바이스 드라이버 레이어 계층 위에 존재하며, 그 이름은 agnostic network interfeace이다.
이것은 결국 2개의 기능을 하는데, dev<em>queue</em>xmit() / netif_rx() 이 두 함수를 이용해서 wifi packet rate만을 process 단위로 판독 한다.</p>
<h5 id="toc_19">4.5 3G Usage</h5>

<h5 id="toc_20">5.1 Component Usage Monitoring</h5>
<p>실험을 통해서 정확하게 하드웨어 컴포넌트들의 사용량을 관찰 할 수 있다는 것을 보인다.
이를 통해서 정확한 Power consumption characteristics를 계산 할 수 있다.</p>
<h5 id="toc_21">5.2 Energy Metering Validation</h5>

<h5 id="toc_22">5.2.2 Accuracy</h5>
<p>오차의 원인은 2가지이다.<br>
<code>1)</code> Wi-Fi에서 3G로 전환되는것을 발견하지 못해서 생기는것<br>
<code>2)</code> This demonstrates the limitations of our simple CPU power model, which ignores the effects of cache, bus, memory and other SoC components.<br>
2번 문제를 해결하기 위해서는 performance counter를 이용해서 정확한 power model을 생성하면 된다.
관련 논문은 아래와 같다.</p>
<blockquote>
<ul>
<li><p>D. Snowdon, E. Le Sueur, S. Petters, and G. Heiser. Koala: A Platform for OS-level Power Management. In EuroSys, 2009.</p></li>
<li><p>Y. Xiao, R. Bhaumik, Z. Yang, M. Siekkinen, P. Savo-lainen, and A. Yla-Jaaski. A System-level Model for Runtime Power Estimation on Mobile Devices. In GreenCom-CPSCom, 2010.</p></li>
<li><p>T. Li and L. John. Run-time Modeling and Estimation of Operating System Power Consumption. ACM SIGMET-RICS Performance Evaluation Review, volume 31, pages 160–171, 2003.</p></li>
<li><p>S. Gurun and C. Krintz. A Run-time, Feedback-based Energy Estimation Model for Embedded Devices. In CODES+ISSS, 2006.</p></li>
<li><p>K. Singh, M. Bhadauria, and S. McKee. Real Time Power Estimation and Thread Scheduling via Performance Counters. ACM SIGARCH Computer Architecture News, 37(2):46–55, 2009.</p></li>
</ul>
</blockquote>

<h5 id="toc_23">5.3 Overhead Analysis</h5>
<p>오버해드 또한 상당히 적다는 것을 알 수 있다.
리눅스 커널 모듈로 개발되어서 그런지 overhead는 각각
매초당 평균 34.9mW 정도이고
CPU overhead는 2.1% 정도의 이용률 증가를 가져온다.
최악의 경우에도 5.9%를 넘어서지 않는다.</p>
<h3 id="toc_24">6. Real Application Energy Metering</h3>
<p>AngryBirds가 에너지 에러가 가자 크다.
300mW정도의 평균적인 에러를 보인다.</p><p><img src="http://cfile2.uf.tistory.com/image/11747B4D500131C01F273D" alt="&lt;Display Name&gt;"></p><p>핵심적인 것은 wifi가 사용중이 아닌 약 20초 동안의 구간에 대해서 에러가 크게 발생한다는 것이다.</p><p>We understand that the game activates N1&#39;s GPU(Integrated Graphics Processing Unit Adreno 200 on Qualcomm QSD8250 Snapdragon) and error is caused by this hardware component.  </p>
<blockquote>
<p>CPU/GPU를 벤치마크하는 도구이다.<br>
[27] : [StabilityTest] [<a href="https://play.google.com/store/apps/details?id=com.into.stability">https://play.google.com/store/apps/details?id=com.into.stability</a>]</p></blockquote>
<p><img src="http://cfile28.uf.tistory.com/image/184B5A485001336A35D0CC" alt="&lt;Display Name&gt;"></p><p>3D 객체를 37초까지 만듬다음 그다음 부터 주기적으로 로테이션하는 벤치마크를 돌린결과
위와 같은 에너지 소모 차리를 보였다.</p><p>b는 항시 직접 측정 전력 소모값이 더 높은 에너지 소모를 가져오며, c의 경우 항시 낮은 전력 소모를 가져 온다. 이러한 차이는 선형 회귀 분석을 통한 전력 모델 생성 방식의 한계라고 볼 수있다.
왜냐하면, WiFi 인터페이스는 항상 CPU를 가동함에도 불구하고, 우리의 전력 모델은 wifi와 cpu간의 inter dependency를 고려하지 않았다. 이 제한사항은 아마도 cross-terms 모델링을 사용함으로써 극복 되어 질수 있을 것이다. 이러한 각 component들 사이의 inter dependency를 고려한 모델링 방법은 관련연구[5]에서 다루고 있다.  </p>
<blockquote>
<p>[5] D. Snowdon, E. Le Sueur, S. Petters, and G. Heiser. Koala: A Platform for OS-level Power Management. In EuroSys, 2009.</p></blockquote>
<p>그림 a와 b와 d를 보면 순간적으로 LCD나 3G의 전력 소모가 순간적으로 올라가는 현상을 볼 수 있다.
이러한 문제점은 이 AppScope을 구현하는데 사용한 SystemTap[24]의 버그 때문이다. 즉 2초간의 데이터가 누적 되어지기때문에 일시적으로 이와 같은 현상이 발생 하는 것이다.</p>
<blockquote>
<p>[24] SystemTap, <a href="http://sourceware.org/systemtap">http://sourceware.org/systemtap</a>.</p></blockquote>

<h3 id="toc_25">7. Related Work</h3>
<p>최신 연구 스마트폰 전력 모델을 만들어서 전력 소모를 측정하는 논문에는 아래의 것들이 있다.</p>
<blockquote>
<p>[7] L. Zhang, B. Tiwana, Z. Qian, Z. Wang, R. Dick, Z. Mao, and L. Yang. Accurate Online Power Estimation and Automatic Battery Behavior based Power Model Gener-ation for Smartphones. In CODES+ISSS, 2010. (Power Tutor)</p><p>[9] M. B. Kjærgaard and H. Blunck. Unsupervised Power Profiling for Mobile Devices. In Mobiquitous, 2011. (PowerProf)</p><p>[14] A. Pathak, Y. Hu, M. Zhang, P. Bahl, and Y. Wang. Fi-ne-grained Power Modeling for Smartphones Using System Call Tracing. In EuroSys, 2011. (Eprof)</p><p>[16] M. Dong and L. Zhong. Self-constructive High-rate Sys-tem Energy Modeling for Battery-powered Mobile Sys-tems. In MobiSys, 2011.</p></blockquote>
<p>14번 연구 Pathak의 연구가 가장 위 연구에 도전적인 연구이지만, 저자는 이렇게 비난하고 있다.
이것은 External power measurement tool을 필요로 하며, 이것은 파워모델을 생산해 내기위해서 target device들의 상세한 power state를 알아낼 필요가 있다는 한계를 가진다.</p>
<h2 id="toc_26"></h2>
<p>PowerTutor의 비난 내용<br>
1) 하드웨어 사용량을 알아내기 위해서, procfs와 BatteryStat를 사용 한다.<br>
2) 이렇게 특수 파일 시스템만을 이용해서 하드웨어 컴포넌트들의 사용 통계량을 계산하기 때문에 한계 4.1의 내용으로 인해 정확성을 보장하지 못하게 된다.  </p>
<blockquote>
<ul>
<li>한계 4.1의 설명 -<br>
1) 어떻게 접근하느냐에 따라서 다르다.즉 한상 폴링하고 있어야 한다.<br>
2) wifi 트래픽을 프로세스 단위로 제공하지 않으며 GPS도 마찬가지이다. 즉 이러한 특수 파일 시스템의 타입에 매우 의존적으로 지원이 가능하다.<br>
3) 비록 위 2개의 제한 사항들이 커널을 수정함으로써 모두 극복되어 질 수 있지만, 그럴경우 diverse platform들에 대해서 적용하기가 힘들다는 단점을 가진다.<br></li>
</ul>
</blockquote>
<p>3) Power Tutor는 UID에 대해서는 지원하지만 PID에 대해서는 지원하지 않는다. 더구나 이 UID에 대해서도 GPS와 AUDIO에 대해서 완벽하게 지원하게 하기 위해서는 커널을 수정해야 하는 단점을 가지게 된다.</p><p>이에 반에 우리는 커널 수정도 필요없고, 폴링도 안해서 성능저하도 없으며, PID 단위의 높은 수준의 granularity 또한 제공 한다.</p>
<h6 id="toc_27">PowerProf[9]의 비난 내용</h6>
<p>이것은 노키아 폰에서의 Eenrgy Profiler를 이용한 자동 전력 모델 생성이다. 즉
어떤 genetic algorithm을 이용해서 자동으로 하드웨어 컴포넌트들의 전력 모델 상태를 알아낼 수 있는 것이다.
1) application energy metering에 대해서 빠져 있다.</p>
<h6 id="toc_28">Eprof[29]의 비난 내용</h6>
<p>1) 강력하지만, 이것은 post-processing을 거처야 하며, API call들을 제대로 트레이싱 하기위해서는 Android framework를 고쳐야한다. 또한 application code또한 거쳐야 한다. Android NDK일경우 더 골치아파진다. 따라서 리얼타임성이 떨어지며, 적용이 번거롭다는 단점을 가진다.</p>
<h2 id="toc_29"></h2>
<p>PowerScope[6]: 추가적인 컴퓨팅 리소스를필요로 하지만 프로세스 단위의 에너지 추정이 가능하다.<br>
Quanto[30]: To develope as a network wide energy profiler for fast energy metering based on event driven methods in TinyOS.( 본 연구의 기법과 가장 유사한 방법이다.)</p>
<blockquote>
<p>[6] J. Flinn and M. Satyanarayanan. Powerscope: A Tool for Profiling the Energy Usage of Mobile Applications. In IEEE WMCSA, 1999.</p><p>[30] R. Fonseca, P. Dutta, P. Levis, and I. Stoica. Quanto: Tracking Energy in Networked Embedded Systems. In USENIX OSDI, 2008.</p></blockquote>

<h2 id="toc_30"></h2>
<p>AppScope의 정보 획득 방식과 가장 유사한 연구들은 [1-5]이다.</p>
<blockquote>
<p>[1] H. Zeng, C. Ellis, A. Lebeck, and A. Vahdat. Ecosystem: Managing Energy as a First Class Operating System Re-source, ACM SIGPLAN Notices, volume 37, pages 123–132, 2002.<br>
[2] H. Zeng, C. Ellis, A. Lebeck, and A. Vahdat. Currentcy: A Unifying Abstraction for Expressing Energy Manage-ment Policies. In USENIX ATC, 2003.<br>
[3] H. Zeng, C. Ellis, and A. Lebeck. Experiences in Man-aging Energy with Ecosystem. IEEE Pervasive Compu-ting, 4(1):62–68, 2005.<br>
[4] A. Roy, S. Rumble, R. Stutsman, P. Levis, D. Mazières, and N. Zeldovich. Energy Management in Mobile De-vices with the Cinder Operating Systemg. In EuroSys, 2011.<br>
[5] D. Snowdon, E. Le Sueur, S. Petters, and G. Heiser. Koala: A Platform for OS-level Power Management. In EuroSys, 2009</p></blockquote>

<h2 id="toc_31"></h2>

<h3 id="toc_32">8. Discussion</h3>
<p>1) 결국 memory와 GPU 그리고 multicore CPU 아키텍쳐에서의 전력 모델생성이 중요하다고 볼 수 있다.<br>
2) tail state energy cellular, wifi, gps를 디텍션 할수가 없다. 결국 이것은 utilization based power model과 linear power model의 단점이라고 할 수 있겠다.</p>
<h3 id="toc_33">9. Conclusion</h3>

                        </div>
                        <hr />
                                            
                        <div class="row-fluid">
                            
                            <div class="pull-right">
                                <a href="/post/batterymanager-yoyag" class="btn btn-info">Batterymanager 요약 <i class="icon-white icon-chevron-right"></i></a>
                            </div>
                            

                            
                        </div>
                    

                        
                    </div>
                </div>
            </div>
            <div class="row">
            </div>
        </div>
    </div>
    <!--<div class="row">-->
        <!--<div class="offset3 span9">-->
            <!--<strong>tags</strong> :-->
            <!---->
            <!--<a href="/tag/paper">paper</a>&nbsp;-->
            <!---->
            <!--<a href="/tag/Appscope">Appscope</a>&nbsp;-->
            <!---->
        <!--</div>-->
    <!--</div>-->
</div><!-- /container -->


        <footer class="footer">
        <div class="container">
            <div class="row">
                <div class="span12 ">
                    <div class="well">
                        <p class="pull-right"><a href="#">Back to top</a></p>
                            <strong>haroopress</strong> developed by <a href="http://twitter.com/rhiokim" target="_blank">@rhiokim</a>,<a href="http://twitter.com/haroopress" target="_blank">@haroopress</a> and source in <a href="https://github.com/rhiokim/haroopress" target="_blank">github</a><br/>
                            Designed and built with all the love in the world <a href="http://twitter.com/twitter" target="_blank">@twitter</a> by <a href="http://twitter.com/mdo" target="_blank">@mdo</a> and <a href="http://twitter.com/fat" target="_blank">@fat</a>.<br />
                            Code licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License v2.0</a>. Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.
                    </div>
                </div>
            </div>
        </div>
    </footer>

    


</body>
</html>
